/** 
 *  Storage string HUFF EXERCISE
 *
 * In this puzzle, the task is to simulate an array in Huff using the "exact"
 * storage pattern as solidity. Expected functions can; 
 *      - sets string
 *      - reads string
 *
 *  NOTICE: The contract should revert when an unrecognized function is called
 */

#define function getValue() view returns (string)
#define function setValue(string memory) nonpayable returns () 

#define constant SIZE = FREE_STORAGE_POINTER()


#define macro DISPATCH(fn_get, fn_set) = takes(0) returns(0) {
    // Get the fn sig from calldata
    push0 calldataload 0xE0 shr   // [callSig]
    dup1 __FUNC_SIG(getValue)  eq <fn_get>  jumpi 
    __FUNC_SIG(setValue)       eq <fn_set>  jumpi 

    push0 push0 revert
}

#define macro IS_ODD() = takes(1) returns(1) {
    // input [n]
    // output [bool]
    0x01 and                // [bool]
}

#define macro RETURN_1() = takes(0) returns(0) {
    // input [head]
    dup1                    // [head, head]
    0xff and                // [2*len, head]
    0x1 shr                 // [len, head]

    0x20 0x00 mstore        // [len, head]
    0x20 mstore             // [head]
    dup1                    // [head, head]
    0x1f byte               // [byte, head]
    xor                     // [head ^ byte]
    0x40 mstore             // []
    0x60 0x00 return
}

#define macro RETURN_N() = takes(0) returns(0) {
    // input [head]
    // get head of string storage
    0x1 shr                   // [size//2]
    0x20                      // [0x20, size]
    dup2                      // [size, 0x20, size]
    div                       // [quotient, size]
    dup2                      // [size, quotient, size]
    0x20                      // [0x20, size, quotient, size]
    swap1                     // [size, 0x20, quotient, size]
    mod                       // [remainder, quotient, size]
    iszero read_loop jumpi    // [quotient, size]
    0x01 add                  // [++quotient, size]

    dup1                      // [slots, slots, size]
    0x20 mul                  // [32*slots, slots, size]
    0x40 add                  // [totalsize, slots, size]
    swap2                     // [size, slots, totalsize]
    swap1                     // [slots, size, totalsize]


    read_loop:                // [slots, size, totalsize]
        0x20 0x80 mstore      // [slots, size, totalsize]
        swap1                 // [size, slots, totalsize]
        0xa0 mstore           // [slots, totalsize]
        0xc0                  // [optr, slots, totalsize]

        0x00 0x00 mstore      // [optr, slots, totalsize]
        0x20 0x00 sha3        // [iptr, optr, slots, totalsize]
        do:
            dup1              // [iptr, iptr, optr, slots, totalsize]
            sload             // [w, iptr, optr, slots, totalsize]
            dup3              // [optr, w, iptr, optr, slots, totalsize]
            mstore            // [iptr, optr, slots, totalsize]
            0x01 add          // [++iptr, optr, slots, totalsize]
            swap1             // [optr, ++iptr, slots, totalsize]
            0x20 add          // [++optr, iptr, slots, totalsize]
            swap2             // [slots, iptr, optr, totalsize]    
            0x01 swap1        // [slots, 1, iptr, optr, totalsize]
            sub               // [--slots, iptr, optr, totalsize]
            dup1              // [slots, slots, iptr, optr, totalsize]
            iszero fin jumpi  // [slots, iptr, optr, totalsize]
            swap2             // [optr, iptr, slots, totalsize]
            swap1             // [iptr, optr, slots, totalsize]
            do jump

        fin:                  // [slots, iptr, optr, totalsize]
            swap3             // [totalsize, iptr, optr, slots]
            0x80 return
}

#define macro GET() = takes(0) returns(0) {
    // get head of string storage
    0x00 sload               // [head]
    dup1                     // [head, head]
    IS_ODD() odd jumpi       // [head]

    RETURN_1()               // [head]

    odd:
        RETURN_N()           // [head]
}

#define macro StoreOneWord() = takes(1) returns(0) {
    // get head of string storage
    0x01 shl                 // [2*size]
    0x44 calldataload        // [str, 2*size]
    or                       // [head]
    0x00 sstore              // []
    stop
}

#define macro StoreNWords() = takes(1) returns(0) {
    // get head of string storage
    0x20                     // [0x20, size]
    dup2                     // [size, 0x20, size]
    div                      // [quotient, size]
    dup2                     // [size, quotient, size]
    0x20                     // [0x20, size, quotient, size]
    mod                      // [remainder, quotient, size]
    iszero save_loop jumpi   // [quotient, size]
    0x01 add                 // [++quotient, size]


    save_loop:               // [slots=quotient, size]
        swap1                // [size, slots]
        0x01 shl             // [encodedLen = 2*size, slots]
        0x01 add             // [++encodedLen, slots]
        0x00 sstore          // [slots]

        0x00 0x00 mstore     // [slots]
        0x20 0x00 sha3       // [optr, slots]
        0x44                 // [iptr=0x44, optr, slots]

        do: 
            // read n 
            dup1            // [iptr, iptr, optr, slots]
            calldataload    // [w, iptr, optr, slots]
            dup3            // [optr, w, iptr, optr, slots]
            sstore          // [iptr, optr, slots]

            0x20 add       // [++iptr, optr, slots]
            swap1          // [optr, ++iptr, slots]
            0x01 add       // [++optr, iptr, slots]
            swap1          // [iptr, optr, slots]

            0x01          // [0x01, iptr, optr, slots]
            dup4          // [slots, 0x01, iptr, optr, slots]
            sub           // [--slots, iptr, optr, slots]
            swap3         // [slots, iptr, optr, slots-1]

// TODO: test this logic with 
// s31, s32, s63, s64, s65
            0x01 gt       // [b, iptr, optr, slots-1]
            iszero do jumpi   // [iptr, optr, slots-1]
//      while slots >= 1
            stop
}

#define macro SET() = takes(0) returns(0) {
    // get head of string storage
    0x24 calldataload        // [size]
    dup1                     // [size, size]

    // 32 > size
    0x32 gt set_1w jumpi     // [size]

    StoreNWords()

    set_1w:
        StoreOneWord()
}


#define macro MAIN() = takes(0) returns(0) {
    DISPATCH(fn_get, fn_set) 

    fn_get:
        GET()

    fn_set:
        SET()

}

/*
setValue(Hello)
0x93a093520000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000548656c6c6f000000000000000000000000000000000000000000000000000000

getValue()
0x20965255

setValue(string) "Hello I love you let me get in your game. Hellbent for leather"
0x93a093520000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000003e48656c6c6f2049206c6f766520796f75206c6574206d652067657420696e20796f75722067616d652e2048656c6c62656e7420666f72206c6561746865720000

*/
